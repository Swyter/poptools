//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: Prince of Persia: The Forgotten Sands (Wii) - Save game format
//   Authors: Swyter
//   Version: 2023.03.20
//  Category: Game
// File Mask: djinn*
//  ID Bytes: [+4] 4E 49 4A 44
//------------------------------------------------

BigEndian();

uint size_maybe;

struct
{
    char magic[4];
    uint version;


    int unk[24 / 4];
    ubyte data[size_maybe];

} head <open=true>;


/* swy: actual file ends here -- there's a trailing outer checksum; see revoINO_ReadFile() at offset 0x80556130 */
FSeek(FileSize() - 32);
int weird_constants[32 / 4] <format=hex>;


/* -- */

local int m_WeirdConstant[8] <format=hex>;

local uint buf = 0, buf_end = FileSize() - 32, read_size = buf_end;

void djinn_compute_checksum()
{
    m_WeirdConstant[0] = 0x011;
    m_WeirdConstant[1] = 0x05e;
    m_WeirdConstant[2] = 0x115;
    m_WeirdConstant[3] = 0x236;
    m_WeirdConstant[4] = 0x3c1;
    m_WeirdConstant[5] = 0x5b6;
    m_WeirdConstant[6] = 0x815;
    m_WeirdConstant[7] = 0xade;
    
    local uint count = 5;
    local uint uint_size = (buf_end + (3 - buf)) >> 2; /* swy: byte size / 4; so 0x20000 / 4 = 0x8000 */
    
    if (!(buf < buf_end))
    {
        Error("swy: no space for a checksum right after the end of the game data.");
        return;
    }

    local uint four_uint_size = (uint)(buf_end + (3 - buf)) >> 4; /* swy: 0x20000 / 4 / 4 = 0x2000 */
    local uint pBuf = buf, idx_a, idx_b;
    if (four_uint_size != 0)
    {
        /* swy: unrolled loop */
        do
        {
            idx_a = (count + 3) * 4 & 0x1c;
            m_WeirdConstant[count / 4] = m_WeirdConstant[count    ] + ReadInt(pBuf + 0);
            count = (count + 3 & 7) + 3;
            idx_b = (count * 4) & 0x1c;
            count = (count & 7) + 3;
            m_WeirdConstant[idx_a / 4] = m_WeirdConstant[idx_a / 4] + ReadInt(pBuf + 1);
            
            idx_a = (count * 4) & 0x1c;
            count = ((count & 7) + 3) & 7;
            m_WeirdConstant[idx_b / 4] = m_WeirdConstant[idx_b / 4] + ReadInt(pBuf + 2);
            
            m_WeirdConstant[idx_a / 4] = m_WeirdConstant[idx_a / 4] + ReadInt(pBuf + 3);
        
            pBuf = pBuf + 4; four_uint_size -= 1;
        } while (four_uint_size != 0);
    }

    uint_size &= 3;

    if (uint_size == 0);
        return;
    
    /* swy: for the remaining unaligned bytes; process them individually one by one */
    do
    {
        m_WeirdConstant[count / 4] = m_WeirdConstant[count] + ReadInt(pBuf + 0);
        uint_size -= 1;
        count = (count + 3) & 7;
        pBuf = pBuf + 1;
    } while (uint_size != 0);
}

djinn_compute_checksum();

Printf(
    " %8x %8x %8x %8x %8x %8x %8x %8x - computed\n" +
    " %8x %8x %8x %8x %8x %8x %8x %8x - orig\n", m_WeirdConstant[0], m_WeirdConstant[1], m_WeirdConstant[2], m_WeirdConstant[3], m_WeirdConstant[4], m_WeirdConstant[5], m_WeirdConstant[6], m_WeirdConstant[7],
                                                 weird_constants[0], weird_constants[1], weird_constants[2], weird_constants[3], weird_constants[4], weird_constants[5], weird_constants[6], weird_constants[7]
);

/* swy: check_checksum */
  if (m_WeirdConstant[0] == ReadInt(buf + read_size + 0))
    if (m_WeirdConstant[1] == ReadInt(buf + read_size + 4))
      if (m_WeirdConstant[2] == ReadInt(buf + read_size + 8))
        if (m_WeirdConstant[3] == ReadInt(buf + read_size + 0xc))
          if (m_WeirdConstant[4] == ReadInt(buf + read_size + 0x10))
            if (m_WeirdConstant[5] == ReadInt(buf + read_size + 0x14))
              if (m_WeirdConstant[6] == ReadInt(buf + read_size + 0x18))
                if (m_WeirdConstant[7] == ReadInt(buf + read_size + 0x1c))
                    Printf("[i] checksum matches\n");