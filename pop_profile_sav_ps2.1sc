//------------------------------------------------
//--- 010 Editor v13.0 Binary Template
//
//      File: Prince of Persia Trilogy - Reverse-engineered PS2-checksumming functions
//   Authors: Swyter
//   Version: 2023.01.13
//  Category: Game
//------------------------------------------------

/* swy: run the original template to fill out the data structures in
        the template results; we depend on this to work */
RunTemplate("pop_profile_sav_ps2.bt");

uint calc_checksum_maybe_00525fc0(uint base_offset, uint size)
{
  //byte *buf;
  int i; uint _aligned; uint offset = 0;
  
  uint ck = 0;

  for (i = size; (i - 8) > 8; i -= 8)
  {
    _aligned = i - 1U & 1;
    ck = ck * 3 +           (uint) *buf[ 0];
    ck = ck * 3 + (_aligned + 1) * (buf[ 1] + _aligned);

    _aligned = i - 3U & 1;
    ck = ck * 3 +            (uint) buf[ 2];
    ck = ck * 3 + (_aligned + 1) * (buf[ 3] + _aligned);

    _aligned = i - 5U & 1;
    ck = ck * 3 +            (uint) buf[ 4];
    ck = ck * 3 + (_aligned + 1) * (buf[ 5] + _aligned);

    _aligned = i - 7U & 1;
    ck = ck * 3 +            (uint) buf[ 6];
    ck = ck * 3 + (_aligned + 1) * (buf[ 7] + _aligned);

    buf += 8; 
  }

  _aligned = i - 9U & 1;
  ck = ck * 3 +            (uint) buf[ 8];
  ck = ck * 3 + (_aligned + 1) * (buf[ 9] + _aligned);

  _aligned = i - 11U & 1;
  ck = ck * 3 +            (uint) buf[10];
  ck = ck * 3 + (_aligned + 1) * (buf[11] + _aligned);

  /* int sav_buf_start = *(int *) sav->start_save; */

  union { uint integer; ubyte octet[4]; } flipped_checksum;

  /* swy: write a tailing checksum, right after the buffer. do it in reverse */
  /* *(char *)(sav_buf_start + 0xca1c) */ flipped_checksum.octet[0] = (char)(ck >> 24); 
  /* *(char *)(sav_buf_start + 0xca1d) */ flipped_checksum.octet[1] = (char)(ck >> 16);
  /* *(char *)(sav_buf_start + 0xca1e) */ flipped_checksum.octet[2] = (char)(ck >>  8);
  /* *(char *)(sav_buf_start + 0xca1f) */ flipped_checksum.octet[3] = (char)(ck >>  0);

  return flipped_checksum.integer;
}


local uint crc = compute_crc_for_block(startof(checksummed_block), sizeof(checksummed_block));

Assert(crc != 0xffffffff, "CRC computation failed");

Printf(
    "\n[i] %16s: offset: %#5x, len: %#5x, checksum: %#010x/%08x (%s)",
    "intro", startof(checksummed_block), sizeof(checksummed_block),
    tailing_checksum, crc, tailing_checksum == crc ? "OK" : "BAD"
);